import hashlib
import datetime


class Database(object):
    def __init__(self):
        pass

    def _connect_to_db(self, db_type, database, log, db_ini=None, create=False):
        if db_type == "sqlite":
            import sqlite3

            db = sqlite3.connect(database)
        elif db_type == "postgres":
            import psycopg2
            from configparser import ConfigParser

            # parse ini file
            parser = ConfigParser()
            parser.read(db_ini)
            ini_data = {_[0]: _[1] for _ in parser.items("postgresql")}
            if create:  # only need to do this if creating a database
                conn = psycopg2.connect(
                    f"user={ini_data['user']} password={ini_data['password']} dbname=postgres"
                )
                cursor = conn.cursor()
                # try to create database, except will rollback
                try:
                    conn.autocommit = True  # need to create database
                    cursor.execute(f"CREATE DATABASE {database}")
                    conn.commit()
                except:
                    conn.rollback()
                    cursor.close()
                    log.debug("Database exists in postgres client.")
            # connect to database
            db = psycopg2.connect(
                f"user={ini_data['user']} password={ini_data['password']} dbname={database}"
            )
        else:
            raise NotImplementedError(
                "Database type (-db) "
                + db_type
                + " not implemented. Options: sqlite, postgres."
            )
        return db, db.cursor()

    def _prepare_db(self, config):
        if config.args.hash_value is None:
            config.args.hash_value = hashlib.shake_256(
                (str(datetime.datetime.now()) + config.protein_sequence).encode()
            ).hexdigest(5)
            config.log.debug(
                "Job Hash generated by hashlib: " + str(config.args.hash_value)
            )
        try:
            if config.args.database_type == "sqlite":
                primary_key_type = "INTEGER"
            elif config.args.database_type == "postgres":
                primary_key_type = "SERIAL"
            config.db_cursor.execute(
                f"""CREATE TABLE SIM_DETAILS (sim_key {primary_key_type}
                PRIMARY KEY, protein_seq_file VARCHAR, protein_sequence VARCHAR,
                 target VARCHAR, population_size INT,
                 codon_iterations INT, codon_optimizer VARCHAR(10),
                 random_seed INT, min_free_energy FLOAT,
                 target_min_free_energy FLOAT, solver
                 VARCHAR(20), rna_iterations INT, min_stem_len
                 INT, min_loop_len INT, species VARCHAR, coeff_max_bond INT,
                 coeff_stem_len INT, generations_sampled INT, state_file
                 VARCHAR, checkpoint_interval INT, convergence INT, hash_value VARCHAR,
                 sequence_rejections INT, num_sequence_changes INT, beta FLOAT,
                 beta_max FLOAT, exchange_frequency INT, mutation_chance FLOAT,
                 crossover_probability FLOAT, convergence_count INT, span INT,
                 pseudo_factor FLOAT, target_stem_length INT);"""
            )
            config.db_cursor.execute(
                f"""CREATE TABLE OUTPUTS (index_key {primary_key_type}
                PRIMARY KEY, sim_key INT, population_key INT, generation INT,
                sequences VARCHAR, energies FLOAT, secondary_structure VARCHAR);"""
            )
            config.db_cursor.execute(
                f"""CREATE TABLE MFE_SEQUENCES (index_key {primary_key_type} PRIMARY KEY,
                sim_key INT, sequences VARCHAR, secondary_structure VARCHAR)"""
            )
            config.log.debug("Created database tables in " + config.args.output + "\n\n")
        except:
            config.db.rollback()
            config.log.debug("Adding data to existing tables within database.\n\n")
            config.db_cursor.execute(
                f"SELECT sim_key FROM SIM_DETAILS WHERE hash_value = '{config.args.hash_value}';"
            )
            if len(config.db_cursor.fetchall()) > 0:
                raise ValueError(
                    "Hash value already exists in database. Please specify another value."
                )
        config.db_cursor.execute(
            f"""INSERT INTO SIM_DETAILS (protein_seq_file, protein_sequence,
            target, population_size, codon_iterations, codon_optimizer,
            random_seed, solver, rna_iterations, min_stem_len,
            min_loop_len, species, coeff_max_bond, coeff_stem_len, state_file,
            convergence, checkpoint_interval, hash_value, sequence_rejections,
            num_sequence_changes, beta, beta_max, exchange_frequency,
            mutation_chance, crossover_probability, convergence_count, span,
            pseudo_factor, target_stem_length) VALUES
            ('{config.args.input}', '{config.protein_sequence}', '{config.args.target}',
            '{config.args.population_size}', '{config.args.codon_iterations}',
            '{config.args.codon_optimizer}', '{config.args.random_seed}',
            '{config.args.solver}', '{config.args.rna_iterations}',
            '{config.args.min_stem_len}', '{config.args.min_loop_len}',
            '{config.args.species}', '{config.args.coeff_max_bond}',
            '{config.args.coeff_stem_len}', '{config.args.state_file}',
            '{config.args.convergence}', '{config.args.checkpoint_interval}',
            '{config.args.hash_value}', '{config.args.sequence_rejections}',
            '{config.args.num_sequence_changes}', '{config.args.beta}',
            '{config.args.beta_max}', '{config.args.exchange_frequency}',
            '{config.args.mutation_chance}', '{config.args.crossover_probability}', 0,
            '{config.args.span}', '{config.args.pseudo_factor}',
            '{config.args.target_stem_length}');"""
        )
        config.db.commit()
        # retrieve the integer value of the key associated with the input protein sequence with associated hash value
        config.db_cursor.execute(
            f"SELECT sim_key FROM SIM_DETAILS WHERE hash_value = '{config.args.hash_value}';"
        )
        config.sim_key = config.db_cursor.fetchall()[0][0]

    def _load_db(self, config):
        """
        Function to load information from previous use of design.py when the
        --resume option is used. This function assumes information for only a
        single optimization is present in the input database

        """
        config.log.debug("Loading info from database " + config.args.input)

        # get column/variable names
        if config.args.database_type == "sqlite":
            config.db_cursor.execute(
                f"SELECT name FROM pragma_table_info('SIM_DETAILS');"
            )
        elif config.args.database_type == "postgres":
            # table name must be lower case for postgres!
            config.db_cursor.execute(
                f"SELECT column_name FROM information_schema.columns WHERE table_name='sim_details' ORDER BY ordinal_position;"
            )
        keys = config.db_cursor.fetchall()
        keys = [_[0] for _ in keys]  # make list from list of tuples

        # get values of variables
        if config.args.hash_value is not None:
            query = f"SELECT * FROM SIM_DETAILS WHERE hash_value = '{config.args.hash_value}';"
        else:
            query = f"SELECT * FROM SIM_DETAILS;"
        try:
            config.db_cursor.execute(query)
        except:
            config.log.error("There was an error retreiving data from the database.")
            raise ValueError("There was an error retreiving data from the database.")
        data = config.db_cursor.fetchall()

        if len(data) == 0:
            config.log.error(
                "No data retrieved from database. Check your inputs or database structure."
            )
            raise ValueError(
                "No data retrieved from database. Check your inputs or database structure."
            )
        elif len(data) > 1 and config.args.hash_value is None:
            config.log.info(
                "No hash value was specified and multiple optimizations are in the database. Using the first listed."
            )

        data = list(data[0])  # make list from tuple

        # mapping values to member attributes
        # manually keeping track of values which are not considered cli arguments, so members of self not config.args
        not_args = [
            "sim_key",
            "protein_sequence",
            "min_free_energy",
            "generations_sampled",
            "target_min_free_energy",
        ]
        mapping = dict(zip(keys, data))
        for key, val in mapping.items():
            if val == "None":  # None values read as strings from db
                val = None
            if key in not_args:
                setattr(config, key, val)
            elif key not in not_args:
                setattr(config.args, key, val)
            else:
                raise ValueError(
                    f"({key}, {val}) undefined. Check your database structure. You could be using an older version of QuVax."
                )

        if config.args.convergence_count == config.args.convergence:
            config.log.info(
                "Optimization was converged in previous run. By resuming, the convergence counter will be reset to zero and the same convergence criteria will be used again."
            )
            config.args.convergence_count = 0

        # originally set the codon iterations to the original number set by user minus the number sampled in previous iterations
        config.args.codon_iterations = (
            config.args.codon_iterations - config.generations_sampled
        )
        # if original number of steps have been completed, and user extends the optimization
        if config.args.extend > 0:
            config.log.info(
                "Extending optimization by " + str(config.args.extend) + " steps"
            )
            config.args.codon_iterations += config.args.extend
            config.db_cursor.execute(
                f"UPDATE SIM_DETAILS SET codon_iterations = '{config.args.codon_iterations + config.generations_sampled}' WHERE sim_key = '{config.sim_key}';"
            )
            config.db.commit()
        elif config.args.codon_iterations == 0 and config.args.extend == 0:
            raise ValueError(
                "Optimization complete. Use -e to extend the optimization if desired. See python design.py --resume -h for details."
            )
        elif config.args.extend < 0:
            raise ValueError("Value for -e cannot be less than zero.")

        # collect final generation of sequences from previous execution of design.py
        config.db_cursor.execute(
            f"SELECT sequences, energies, secondary_structure from OUTPUTS WHERE sim_key = '{config.sim_key}' and generation = '{config.generations_sampled}';"
        )
        data = config.db_cursor.fetchall()
        if len(data) != config.args.population_size:
            raise ValueError(
                "Data set retrieved from Outputs is larger than population size."
            )
        config.initial_sequences = [data[i][0] for i in range(len(data))]
        config.energies = [data[j][1] for j in range(len(data))]
        config.sec_structs = [data[k][2] for k in range(len(data))]
        config.log.debug("Loaded info from database " + config.args.input)

    def _get_sim_details(self, config):
        # query to get sim_detail columns info
        if config.args.database_type == "sqlite":
            config.db_cursor.execute(
                f"SELECT name FROM pragma_table_info('SIM_DETAILS');"
            )
        elif config.args.database_type == "postgres":
            # table name must be lower case for postgres!
            config.db_cursor.execute(
                f"SELECT column_name FROM information_schema.columns WHERE table_name='sim_details' ORDER BY ordinal_position;"
            )
        keys = config.db_cursor.fetchall()
        if config.args.hash_value:
            query = f"SELECT * FROM SIM_DETAILS WHERE hash_value = '{config.args.hash_value}';"
        else:
            query = f"SELECT * FROM SIM_DETAILS;"
        config.db_cursor.execute(query)
        sim_details = config.db_cursor.fetchall()
        if len(sim_details) == 0:
            config.log.error(
                "No data retrieved from database. Check your inputs or database structure."
            )
            raise ValueError(
                "No data retrieved from database. Check your inputs or database structure."
            )
        elif len(sim_details) > 1 and config.args.hash_value is None:
            config.log.info(
                "No hash value was specified and multiple optimizations are in the database. Using the first listed."
            )
        sim_details_dict = {}  # dict to store details for later access
        config.log.debug("Input Optimization Details:")
        for i in range(len(keys)):
            config.log.debug(keys[i][0] + " : " + str(sim_details[0][i]))
            sim_details_dict[keys[i][0]] = sim_details[0][i]
        return sim_details_dict
